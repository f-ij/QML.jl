var documenterSearchIndex = {"docs":
[{"location":"#QML","page":"QML","title":"QML","text":"","category":"section"},{"location":"#Loading","page":"QML","title":"Loading","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"We support three methods of loading a QML file: QML.QQmlApplicationEngine, QML.QQuickView and QQmlComponent. These behave equivalently to the corresponding Qt classes. They have different advantages:","category":"page"},{"location":"","page":"QML","title":"QML","text":"You can simply load a QML file as a QML.QQmlApplicationEngine.\nQML.QQuickView creates a window, so it's not necessary to wrap the QML in ApplicationWindow.\nYou can run QML code contained in a string with QQmlComponent.","category":"page"},{"location":"#QML-modules","page":"QML","title":"QML modules","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"Since QML.jl version 0.2, only the QtDeclarative package is installed by default, which includes only a very limited set of QML modules. Most notably, the Controls and Controls 2 modules are missing. To get these, you need to add the julia packages Qt5QuickControls_jll and Qt5QuickControls2_jll and use these in your Julia file.","category":"page"},{"location":"#Interaction","page":"QML","title":"Interaction","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"Interaction with Julia happens through the following mechanisms:","category":"page"},{"location":"","page":"QML","title":"QML","text":"Call Julia functions from QML, e.g. with @qmlfunction.\nRead and set context properties from Julia and QML, e.g. with keywords to load or set_context_property.\nEmit signals from Julia to QML, e.g. with @emit.\nUse data models, e.g. ListModel or JuliaPropertyMap.","category":"page"},{"location":"","page":"QML","title":"QML","text":"Note that Julia slots appear missing, but they are not needed since it is possible to directly connect a Julia function to a QML signal in the QML code, e.g. with QTimer.","category":"page"},{"location":"#Type-conversion","page":"QML","title":"Type conversion","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"Most fundamental types are converted implicitly. Mind that the default integer type in QML corresponds to Int32 in Julia.","category":"page"},{"location":"","page":"QML","title":"QML","text":"We also convert QVariantMap, exposing the indexing operator [] to access element by a string key. This mostly to deal with arguments passed to the QML append function in list models.","category":"page"},{"location":"#Interface","page":"QML","title":"Interface","text":"","category":"section"},{"location":"","page":"QML","title":"QML","text":"Modules = [QML]","category":"page"},{"location":"","page":"QML","title":"QML","text":"Modules = [QML]","category":"page"},{"location":"#QML.QML","page":"QML","title":"QML.QML","text":"Module for building Qt5 QML graphical user interfaces for Julia programs. Types starting with Q are equivalent of their Qt C++ counterpart, so, unless otherwise noted, they have no Julia docstring and we refer to the Qt documentation for details instead.\n\n\n\n\n\n","category":"module"},{"location":"#QML.JuliaDisplay","page":"QML","title":"QML.JuliaDisplay","text":"struct JuliaDisplay\n\nYou can use display to send images to a JuliaDisplay. There is a corresponding QML block called JuliaDisplay. Of course the display can also be added using pushdisplay!, but passing by value can be more convenient when defining multiple displays in QML. See below for syntax.\n\njulia> using QML\n\njulia> using Plots: plot\n\njulia> function simple_plot(julia_display::JuliaDisplay)\n          x = 0:1:10\n          display(julia_display, plot(x, x, show = false, size = (500, 500)))\n          nothing\n        end;\n\njulia> @qmlfunction simple_plot\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          import QtQuick.Layouts 1.0\n          import org.julialang 1.0\n          ApplicationWindow {\n            visible: true\n            Column {\n              Button {\n                text: \"Plot\"\n                onClicked: Julia.simple_plot(julia_display)\n              }\n              JuliaDisplay {\n                id: julia_display\n                width: 500\n                height: 500\n              }\n              Timer {\n                running: true\n                onTriggered: Qt.quit()\n              }\n            }\n          }\n          \"\"\")\n          loadqml(path)\n          exec()\n        end\n\n\n\n\n\n\n","category":"type"},{"location":"#QML.JuliaPropertyMap-Tuple{Vararg{Pair{var\"#s46\", var\"#s47\"} where {var\"#s46\"<:AbstractString, var\"#s47\"}, N} where N}","page":"QML","title":"QML.JuliaPropertyMap","text":"function JuliaPropertyMap(pairs...)\n\nStore Julia values for access from QML. Observables are connected so they change on the QML side when updated from Julia and vice versa only when passed in a property map. Note that in the example below, if you run output[] = new_value from within Julia, the slider in QML will move.\n\njulia> using QML\n\njulia> using Qt5QuickControls_jll\n\njulia> using Observables: Observable, on\n\njulia> output = Observable(0.0);\n\njulia> on(println, output);\n\njulia> mktempdir() do folder\n         path = joinpath(folder, \"main.qml\")\n         write(path, \"\"\"\n         import QtQuick 2.0\n         import QtQuick.Controls 1.0\n         ApplicationWindow {\n           visible: true\n           Slider {\n             onValueChanged: {\n               observables.output = value;\n             }\n           }\n           Timer {\n             running: true\n             onTriggered: Qt.quit()\n           }\n         }\n         \"\"\")\n         loadqml(path; observables = JuliaPropertyMap(\"output\" => output))\n         exec()\n       end\n\n\n\n\n\n","category":"method"},{"location":"#QML.ListModel-Union{Tuple{AbstractVector{T}}, Tuple{T}, Tuple{AbstractVector{T}, Any}} where T","page":"QML","title":"QML.ListModel","text":"function ListModel(items::AbstractVector, addroles::Bool = true)\n\nConstructor for a ListModel. The ListModel type allows using data in QML views such as ListView and Repeater, providing a two-way synchronization of the data. A ListModel is constructed from a 1D Julia array. To use the model from QML, it can be exposed as a context attribute.\n\nA constructor (the eltype) and setter and getter \"roles\" based on the fieldnames of the eltype will be automatically created if addroles is true.\n\nIf new elements need to be constructed from QML, a constructor can also be provided, using the setconstructor method. QML can pass a list of arguments to constructors.\n\nIn Qt, each of the elements of a model has a series of roles, available as properties in the delegate that is used to display each item. The roles can be added using the addrole function.\n\njulia> using QML\n\njulia> using Qt5QuickControls_jll\n\njulia> mutable struct Fruit\n          name::String\n          cost::Float64\n        end\n\njulia> fruits = ListModel([Fruit(\"apple\", 1.0), Fruit(\"orange\", 2.0)]);\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          import QtQuick.Layouts 1.0\n          ApplicationWindow {\n            visible: true\n            ListView {\n              model: fruits\n              anchors.fill: parent\n              delegate:\n                Row {\n                  Text {\n                    text: name\n                  }\n                  Button {\n                    text: \"Sale\"\n                    onClicked: cost = cost / 2\n                  }\n                  Button {\n                    text: \"Duplicate\"\n                    onClicked: fruits.append([name, cost])\n                  }\n                  Timer {\n                    running: true\n                    onTriggered: Qt.quit()\n                  }\n                }\n              }\n            }\n          \"\"\")\n          loadqml(path; fruits = fruits)\n          exec()\n        end\n\n\n\n\n\n","category":"method"},{"location":"#QML.QByteArray","page":"QML","title":"QML.QByteArray","text":"function QByteArray(a_string::String)\n\nUse to pass text to set_data.\n\n\n\n\n\n","category":"type"},{"location":"#QML.QQmlApplicationEngine","page":"QML","title":"QML.QQmlApplicationEngine","text":"struct QQmlApplicationEngine\n\nOne of 3 ways to interact with QML (the others being QQuickView and QQmlComponent. You can load a QML file to create an engine with load. Use exec to execute a file after it's been loaded.\n\nThe lifetime of the QQmlApplicationEngine is managed from C++ and it gets cleaned up when the application  quits. This means it is not necessary to keep a reference to the engine to prevent it from being garbage collected prematurely.\n\njulia> using QML\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          ApplicationWindow {\n            visible: true\n            Text {\n              text: greeting\n            }\n            Timer {\n              running: true\n              onTriggered: Qt.quit()\n            }\n          }\n          \"\"\")\n          loadqml(path; greeting = \"Hello, World!\")\n          exec()\n        end\n\n\n\n\n\n","category":"type"},{"location":"#QML.QQmlComponent","page":"QML","title":"QML.QQmlComponent","text":"struct QQmlComponent\n\nOne of 3 ways to interact with QML (the others being QQmlApplicationEngine and QQuickView. Make from an engine from e.g.init_qmlengine. Use set_data to set the QML code, create to create the window, and exec to fill the window.\n\njulia> using QML\n\njulia> component = QQmlComponent(init_qmlengine());\n\njulia> set_data(component, QByteArray(\"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          ApplicationWindow {\n            visible: true\n            Rectangle {\n              Text {\n                text: \"Hello, World!\"\n              }\n              Timer {\n                running: true\n                onTriggered: Qt.quit()\n              }\n            }\n          }\n        \"\"\"), QUrl())\n\njulia> create(component, qmlcontext())\n\njulia> exec()\n\n\n\n\n\n","category":"type"},{"location":"#QML.QQuickView","page":"QML","title":"QML.QQuickView","text":"struct QQuickView\n\nOne of 3 ways to interact with QML (the others being QQmlApplicationEngine and QQmlComponent. QQuickView creates a window, so it's not necessary to wrap the QML in ApplicationWindow. Use init_qquickview to create a quick view, set_source to set the source for the quick view, QML.show to view, and exec to execute.\n\njulia> using QML\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          Rectangle {\n            Text {\n              text: \"Hello, World!\"\n            }\n            Timer {\n              running: true\n              onTriggered: Qt.quit()\n            }\n          }\n          \"\"\")\n          quick_view = init_qquickview()\n          set_source(quick_view, QUrlFromLocalFile(path))\n          QML.show(quick_view)\n          exec()\n        end\n\n\n\n\n\n","category":"type"},{"location":"#QML.QTimer","page":"QML","title":"QML.QTimer","text":"struct QTimer\n\nYou can use QTimer to simulate running Julia in the background. Note that QML provides the infrastructure to connect to the QTimer signal through the Connections item.\n\njulia> using QML\n\njulia> counter = Ref(0);\n\njulia> increment() = counter[] += 1;\n\njulia> @qmlfunction increment\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          import org.julialang 1.0\n          ApplicationWindow {\n              visible: true\n              Connections {\n                target: timer\n                function onTimeout() {\n                  Julia.increment()\n                }\n              }\n              Button {\n                  text: \"Start counting\"\n                  onClicked: timer.start()\n              }\n              Timer { // unrelated, this is a timer to stop and continue testing\n                running: true\n                onTriggered: Qt.quit()\n              }\n          }\n          \"\"\")\n          loadqml(path, timer=QTimer())\n          exec()\n        end\n\n\n\n\n\n","category":"type"},{"location":"#QML.QUrl","page":"QML","title":"QML.QUrl","text":"struct QUrl([filename::String])\n\nUsed to pass filenames to set_source. Pass an empty url (no arguments) to set_data.\n\n\n\n\n\n","category":"type"},{"location":"#QML.addrole","page":"QML","title":"QML.addrole","text":"function addrole(model::ListModel, name::String, getter, [setter])\n\nAdd your own getter (and optionally, setter) functions to a ListModel for use by QML. setter is optional, and if it is not provided the role will be read-only. getter will process an item before it is returned. The arguments of setter will be collection, new_value, index as in the standard setindex! function. If you would like to see the roles defined for a list, use roles. To remove a role, use removerole.\n\njulia> using QML\n\njulia> using Qt5QuickControls_jll\n\njulia> items = [\"A\", \"B\"];\n\njulia> array_model = ListModel(items, false);\n\njulia> addrole(array_model, \"item\", identity, setindex!)\n\njulia> roles(array_model)\n1-element QML.QStringListAllocated:\n \"item\"\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          import QtQuick.Layouts 1.0\n          ApplicationWindow {\n            visible: true\n            ListView {\n              model: array_model\n              anchors.fill: parent\n              delegate: TextField {\n                placeholderText: item\n                onTextChanged: item = text;\n              }\n            }\n            Timer {\n              running: true\n              onTriggered: Qt.quit()\n            }\n          }\n          \"\"\")\n          loadqml(path; array_model = array_model)\n          exec()\n        end\n\njulia> removerole(array_model, \"item\")\n\n\n\n\n\n","category":"function"},{"location":"#QML.content_item","page":"QML","title":"QML.content_item","text":"function content_item(quick_view::QQuickView)\n\nGet the content item of a quick view. Equivalent to QQuickWindow::contentItem.\n\njulia> using QML\n\njulia> using CxxWrap.CxxWrapCore: CxxPtr\n\njulia> quick_view = mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          Rectangle {\n            Timer {\n              running: true\n              onTriggered: Qt.quit()\n            }\n          }\n          \"\"\")\n          quick_view = init_qquickview()\n          set_source(quick_view, QUrlFromLocalFile(path))\n          @assert content_item(quick_view) isa CxxPtr{QQuickItem}\n          exec()\n        end\n\n\n\n\n\n","category":"function"},{"location":"#QML.context_property","page":"QML","title":"QML.context_property","text":"function context_property(context::QQmlContext, item::AbstractString)\n\nGet a context property. See the example for root_context.\n\n\n\n\n\n","category":"function"},{"location":"#QML.create","page":"QML","title":"QML.create","text":"function create(component::QQmlComponent, context::QQmlContext)\n\nEquivalent to QQmlComponent::create. This creates a component defined by the QML code set using set_data. It also makes sure the newly created object is parented to the given context. See the example for set_data.\n\n\n\n\n\n","category":"function"},{"location":"#QML.engine","page":"QML","title":"QML.engine","text":"function engine(quick_view::QQuickView)\n\nEquivalent to QQuickView::engine. If you would like to modify the context of a QQuickView, use engine to get an engine from the window, and then root_context to get the context from the engine.\n\njulia> using QML\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          Rectangle {\n            Text {\n              text: greeting\n            }\n            Timer {\n              running: true\n              onTriggered: Qt.quit()\n            }\n          }\n          \"\"\")\n          quick_view = init_qquickview()\n          context = root_context(engine(quick_view))\n          set_context_property(context, \"greeting\", \"Hello, World!\")\n          set_source(quick_view, QUrlFromLocalFile(path))\n          QML.show(quick_view)\n          exec()\n        end\n\n\n\n\n\n","category":"function"},{"location":"#QML.exec","page":"QML","title":"QML.exec","text":"function exec()\n\nFill out a window. Use with a QQmlApplicationEngine, QQuickView, or QQmlComponent. Note that after calling exec, you will need to reregister functions, e.g. with [@qmlfunction], if you want to exec again.\n\n\n\n\n\n","category":"function"},{"location":"#QML.exec_async","page":"QML","title":"QML.exec_async","text":"function exec_async()\n\nSimilar to exec, but will not block the main process. This method keeps the REPL active and polls the QML interface periodically for events, using a timer in the Julia event loop.\n\n\n\n\n\n","category":"function"},{"location":"#QML.init_qmlengine","page":"QML","title":"QML.init_qmlengine","text":"function init_qmlengine()\n\nCreate a QML engine. You can modify the context of an engine using root_context. You can use an engine to create QQmlComponents. See the example for set_data. Note that you can also get the engine for a QQuickView using engine.\n\n\n\n\n\n","category":"function"},{"location":"#QML.init_qquickview","page":"QML","title":"QML.init_qquickview","text":"function init_qquickview()\n\nCreate a QQuickView.\n\n\n\n\n\n","category":"function"},{"location":"#QML.loadqml-Tuple{Any}","page":"QML","title":"QML.loadqml","text":"function loadqml(qmlfilename; properties...)\n\nLoad a QML file, creating a QML.QQmlApplicationEngine, and setting the context properties supplied in the keyword arguments. Will create and return a QQmlApplicationEngine. See the example for QML.QQmlApplicationEngine.\n\n\n\n\n\n","category":"method"},{"location":"#QML.qmlcontext","page":"QML","title":"QML.qmlcontext","text":"function qmlcontext()\n\nCreate an empty context for QML. Required for create.\n\n\n\n\n\n","category":"function"},{"location":"#QML.qmlfunction","page":"QML","title":"QML.qmlfunction","text":"function qmlfunction(function_name::String, a_function)\n\nRegister a_function using function_name. If you want to register a function under it's own name, you can use @qmlfunction. Note, however, that you can't use the macro for registering functions from a non-exported module or registering functions wtih ! in the name.\n\n\n\n\n\n","category":"function"},{"location":"#QML.qt_prefix_path","page":"QML","title":"QML.qt_prefix_path","text":"function qt_prefix_path()\n\nEquivalent to QLibraryInfo::location(QLibraryInfo::PrefixPath). Useful to check whether the intended Qt version is being used.\n\njulia> using QML\n\njulia> isdir(qt_prefix_path())\ntrue\n\n\n\n\n\n","category":"function"},{"location":"#QML.removerole-Tuple{ListModel, AbstractString}","page":"QML","title":"QML.removerole","text":"function removerole(model::ListModel, name::AbstractString)\n\nRemove one of the roles from a ListModel. See the example for addrole.\n\n\n\n\n\n","category":"method"},{"location":"#QML.roles-Tuple{ListModel}","page":"QML","title":"QML.roles","text":"function roles(model::ListModel)\n\nSee all roles defined for a ListModel. See the example for addrole.\n\n\n\n\n\n","category":"method"},{"location":"#QML.root_context","page":"QML","title":"QML.root_context","text":"root_context(an_engine::QQmlEngine)\n\nGet the context of an_engine. Equivalent to QQmlEngine::rootContext. Use set_context_property to modify the context. Use context_property to get a particular property. Use to get the context of an engine created with init_qmlengine before using set_data or from engine.\n\njulia> using QML\n\njulia> an_engine = init_qmlengine();\n\njulia> context = root_context(an_engine);\n\njulia> set_context_property(context, \"greeting\", \"Hello, World!\");\n\njulia> context_property(context, \"greeting\")\nQVariant of type QML.QString with value Hello, World!\n\njulia> component = QQmlComponent(an_engine);\n\njulia> set_data(component, QByteArray(\"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          ApplicationWindow {\n            visible: true\n            Rectangle {\n              Text {\n                text: greeting\n              }\n              Timer {\n                running: true\n                onTriggered: Qt.quit()\n              }\n            }\n          }\n        \"\"\"), QUrl())\n\njulia> create(component, qmlcontext())\n\njulia> exec()\n\n\n\n\n\n","category":"function"},{"location":"#QML.set_context_property","page":"QML","title":"QML.set_context_property","text":"set_context_property(context::QQmlContext, name::String, value::Any)\n\nSet properties. See root_context for an example.\n\n\n\n\n\n","category":"function"},{"location":"#QML.set_data","page":"QML","title":"QML.set_data","text":"function set_data(component::QQmlComponent, data::QByteArray, file::QUrl)\n\nEquivalent to QQmlComponent::setData. Use this to set the QML code for a QQmlComponent from a Julia string literal wrapped in a QByteArray. Also requires an empty QUrl. See QQmlComponent for an example.\n\n\n\n\n\n","category":"function"},{"location":"#QML.set_source","page":"QML","title":"QML.set_source","text":"function set_source(window::QQuickView, file::QUrl)\n\nEquivalent to QQuickView::setSource. See the example for init_qquickview. The file path should be a path wrapped with QUrl.\n\n\n\n\n\n","category":"function"},{"location":"#QML.setconstructor-Tuple{ListModel, Any}","page":"QML","title":"QML.setconstructor","text":"function setconstructor(model::ListModel, constructor)\n\nAdd a constructor to a ListModel. The constructor will process appended items before they are added. Note that you can simply pass a list of arguments from QML, and they will be interpret in Julia as positional arguments.\n\njulia> using QML\n\njulia> using Qt5QuickControls_jll\n\njulia> items = [\"A\", \"B\"];\n\njulia> array_model = ListModel(items, false);\n\njulia> setconstructor(array_model, uppercase);\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          import QtQuick.Layouts 1.0\n          ApplicationWindow {\n            visible: true\n            Button {\n              text: \"Add C\"\n              onClicked: array_model.append([\"c\"])\n            }\n            Timer {\n              running: true\n              onTriggered: Qt.quit()\n            }\n          }\n          \"\"\")\n          loadqml(path; array_model = array_model)\n          exec()\n        end\n\n\n\n\n\n","category":"method"},{"location":"#QML.show","page":"QML","title":"QML.show","text":" function QML.show()\n\nEquivalent to QQuickView::show. See example for QQuickView.\n\n\n\n\n\n","category":"function"},{"location":"#QML.to_string","page":"QML","title":"QML.to_string","text":"function to_string(data::QByteArray)\n\nEquivalent to QByteArray::toString. Use to convert a QByteArray back to a string.\n\njulia> using QML\n\njulia> to_string(QByteArray(\"Hello, World!\"))\n\"Hello, World!\"\n\n\n\n\n\n","category":"function"},{"location":"#QML.@emit-Tuple{Any}","page":"QML","title":"QML.@emit","text":"@emit signal_name(arguments...)\n\nEmit a signal from Julia to QML. Handle signals in QML using a JuliaSignals block. See the example below for syntax.\n\nwarning: Warning\nThere must never be more than one JuliaSignals block in QML\n\njulia> using QML\n\njulia> using Qt5QuickControls_jll\n\njulia> duplicate(value) = @emit duplicateSignal(value);\n\njulia> @qmlfunction duplicate\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import QtQuick 2.2\n          import QtQuick.Controls 1.1\n          import QtQuick.Layouts 1.1\n          import org.julialang 1.0\n          ApplicationWindow {\n              visible: true\n              Column {\n                TextField {\n                    id: input\n                    onTextChanged: Julia.duplicate(text)\n                }\n                Text {\n                    id: output\n                }\n                JuliaSignals {\n                  signal duplicateSignal(var value)\n                  onDuplicateSignal: output.text = value\n                }\n                Timer {\n                  running: true\n                  onTriggered: Qt.quit()\n                }\n              }\n          }\n          \"\"\")\n          loadqml(path)\n          exec()\n        end\n\n\n\n\n\n","category":"macro"},{"location":"#QML.@expand_dots-Tuple{Any, Any}","page":"QML","title":"QML.@expand_dots","text":"QML.@expand_dots object_.field_ func\n\nExpand an expression of the form a.b.c to replace the dot operator by function calls.\n\njulia> using QML\n\njulia> @macroexpand QML.@expand_dots a.b.c.d f\n:(f(f(f(a, \"b\"), \"c\"), \"d\"))\n\n\n\n\n\n","category":"macro"},{"location":"#QML.@qmlfunction-Tuple","page":"QML","title":"QML.@qmlfunction","text":"@qmlfunction function_names...\n\nRegister Julia functions for access from QML under their own name. Function names must be valid in QML, e.g. they can't contain !. You can use your newly registered functions in QML by first importing org.julialang 1.0, and then calling them with Julia.function_name(arguments...). If you would like to register a function under a different name, use qmlfunction. This will be necessary for non-exported functions from a different module or in case the function contains a ! character.\n\njulia> using QML\n\njulia> using Qt5QuickControls_jll\n\njulia> greet() = \"Hello, World!\";\n\njulia> @qmlfunction greet\n\njulia> mktempdir() do folder\n          path = joinpath(folder, \"main.qml\")\n          write(path, \"\"\"\n          import org.julialang 1.0\n          import QtQuick 2.0\n          import QtQuick.Controls 1.0\n          ApplicationWindow {\n            visible: true\n            Text {\n              text: Julia.greet()\n            }\n            Timer {\n              running: true\n              onTriggered: Qt.quit()\n            }\n          }\n          \"\"\")\n          loadqml(path)\n          exec()\n        end\n\n\n\n\n\n","category":"macro"}]
}
